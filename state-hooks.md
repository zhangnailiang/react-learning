<!-- state hook 原理 -->


当运行函数组件时（调用该函数组件的时候）
<!-- 组件创建： -->
组件是由  React.createElement()创建的
<!-- 在组件中： -->
1. 第N次调用useState节点
2. 检查节点的状态表格是否存在表示已存在状态的下标N
3. 不存在：
    1.使用默认值创建一个状态
    2. 将该状态加入到状态中，下标为N

<!-- 状态改变，重新渲染函数组件： -->
顺序调用组件中的useState时
1. 检查节点的状态表格是否存在表示已存在状态的下标N
2. 存在：
    1. 忽略默认值
    2. 直接返回状态值
<!-- 根节点下渲染两个相同的组件 -->
每一个组件节点都有自己的状态表格，相互之间定义是相同但属于不同的节点和表格。所以组件之间不会相互干扰。

<!-- 注意细节 -->
1. useState最好写在函数的开头
2. useState严禁出现在代码块（循环，判断）中
   原因：每次渲染组件执行所有的 useState，按下标顺序 判断状态是否要更改，判断体中使用useState，不能执行所有的useState，下标对应关系会发生错误。
3. useState。。。
4. 如果使用函数改变数据，如果和之前的数据完全相同，不会导致重新渲染，提升优化效率
5. 使用函数改变数据，传入的值不会和原来的数据进行合并，而是直接替换。
6. 状态之间如果没有关系，应该分化为不同的状态
7. 函数组件的状态改变和类组件的状态改变一样可能是异步的（在DOM事件中），多个状态可能会改变，提高效率，此时不能信任之前的状态，应该使用回调函函数
   调用setXXX改变状态，不会立即改变，在渲染完成之后再进行改变
   多次连续改变状态应该  使用  setXXX(preXXX => preXXX + 1)
                             setXXX(preXXX => preXXX + 1)
   这一次的preXXX会使用上一次的XXX的值
<!-- 强制刷新 -->
类组件：
   class内  render中  使用this.forceUpdate();  此时不会触发shouldComponentUpdate函数
函数组件：
   使用 const [  , forceUpdate] = useState({}); 强制刷新
