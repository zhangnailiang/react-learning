<!-- effect hooks 用于在函数中处理副作用 -->

副作用：
1. ajax
2. 计时器
3. 其他异步操作
4. 更改真实DOM对象
5. 其他会对外部产生影响的操作


useEffect：该函数接受一个函数作为参数，接受的函数就是需要进行副作用操作的函数




<!-- 细节 -->
1. 副作用函数运行的时间点，是在页面完成真实的UI渲染之后，他的执行是异步的，不会阻塞页面的渲染，所以看起来有点慢。
    1.与组件的钩子函数componentDidMount和componentDidUpdate的区别
    2.componentDidMount和componentDidUpdate，改变了真实的DOM，但是用户还没有看到UI更新和同步。
    3.useEffect中的副作用函数，更改了真实DOM，并且用户已经看到UI的更新，异步的。
2. 函数组件中。可以多次在组件中使用useEffect  但是不能在 循环 判断等等待代码块中。
3. useEffect的返回值必须是一个函数，该函数叫做清理函数
   1. 该函数运行的时间点，在每次运行副作用之前
   2. 首次渲染组件不会执行
   3. 组件被销毁时一定会运行  返回值函数
   <!-- 直接使用stop函数 -->
   <!-- return stop;  -->
4. useEffect可以传递第二个参数
    1.第二个参数是一个数组
    2.数组中记录该副作用的依赖依据
    3.当组件重新渲染后，只有依赖数据与上一次不一样的时，才会执行副作用 
    4.所以，当传递了依赖数据之后，如果数据没有发生变化
        1.副作用函数仅在第一次渲染后运行
        2.清理函数仅在卸载组件之后运行
        <!-- 依赖项 主要看useEffect函数中依赖于那些state -->

5. 副作用函数中，如果使用了函数上下文中的变量，则由于闭包的影响，会导致副作用函数中变量不会发生改变。
6. 副作用函数在每次注册的时候，会覆盖之前的副作用函数。因此，尽量保持副作用函数
<!-- 使用空数组作为依赖项，则副作用函数仅在挂载的时候运行 -->
useState(() => {
    ....
}, [])


<!-- 例子 -->
export default function () {
    const [n, setN] = useState(0);
    useEffect(() => {
        setTimeout(() => {
            console.log(n);
        }, 3000)
    })
    return (
        <div>
            <h1>{n}</h1>
            <button onClick={() => {
                setN(n + 1)
            }}>n + 1</button>
        </div>
    )
}
输出   0 1 2 3 4 5 6 7 8 9 和闭包相关的知识（闭包函数的n指向调用函数的上下文的n，每次渲染的上下文是不同的，n也是不同的，所以是0~9）

倒计时写法：

const [n, setN] = useState(0);
useEffect(() => {
    if (n === 0) {
        return;
    }
    setTimeout(() => {
        setN(n - 1);
    }, 1000);
}, [n])